---
phase: 01-codebase-cleanup
plan: 04
type: execute
wave: 2
depends_on:
  - '01-03'
files_modified:
  - app/projects/error.tsx
  - app/projects/loading.tsx
  - app/blog/error.tsx
  - app/blog/loading.tsx
  - app/loading.tsx
autonomous: true
requirements:
  - CLEAN-07
  - CLEAN-08

must_haves:
  truths:
    - 'Visiting /projects when GitHub API is unavailable shows a visible error notice, not an empty page'
    - 'Visiting /blog when no posts load shows the page normally (empty state); an actual runtime error shows the error boundary'
    - 'Visiting /projects shows 3 skeleton cards while data loads'
    - 'Visiting /blog shows post-shaped skeleton rows while data loads'
    - "The error UI tone is casual/light — 'Couldn't reach GitHub' style, not alarming"
    - 'Skeleton cards use opacity-fade pulse animation (Tailwind animate-pulse), not shimmer'
    - "All error.tsx files are Client Components with 'use client' directive"
  artifacts:
    - path: 'app/projects/error.tsx'
      provides: 'Error boundary for /projects route — GitHub fetch failure fallback'
      contains: "'use client'"
    - path: 'app/projects/loading.tsx'
      provides: 'Loading skeleton for /projects — 3 skeleton cards with animate-pulse'
      contains: 'animate-pulse'
    - path: 'app/blog/error.tsx'
      provides: 'Error boundary for /blog route — unexpected error fallback'
      contains: "'use client'"
    - path: 'app/blog/loading.tsx'
      provides: 'Loading skeleton for /blog — post-shaped rows with animate-pulse'
      contains: 'animate-pulse'
  key_links:
    - from: 'app/projects/error.tsx'
      to: 'app/lib/github.ts'
      via: 'error.tsx catches errors thrown by fetchGitHubRepos() in page.tsx'
      pattern: "'use client'"
    - from: 'app/projects/loading.tsx'
      to: 'app/projects/page.tsx'
      via: 'Next.js wraps page in Suspense automatically; loading.tsx shown while page streams in'
      pattern: 'animate-pulse'
    - from: 'app/blog/loading.tsx'
      to: 'app/blog/page.tsx'
      via: 'Next.js wraps blog page in Suspense; loading.tsx shown while posts load'
      pattern: 'animate-pulse'
---

<objective>
Add error.tsx Client Component boundaries and loading.tsx skeleton files for the /projects and /blog route segments. These files are the user-facing layer that makes errors visible and loading states meaningful.

Purpose: Plan 03 made github.ts and blog.ts throw on failure. This plan adds the boundaries that CATCH those throws and show the user a visible, friendly error state instead of an empty page. The loading skeletons give users visual feedback while async data streams in.
Output: Four new files — projects/error.tsx, projects/loading.tsx, blog/error.tsx, blog/loading.tsx — plus updated root loading.tsx.
</objective>

<execution_context>
@C:/Users/xndr/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/xndr/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-codebase-cleanup/01-03-SUMMARY.md
@.planning/codebase/CONVENTIONS.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create error.tsx and loading.tsx for /projects route</name>
  <files>
    app/projects/error.tsx
    app/projects/loading.tsx
  </files>
  <action>
    First, read `app/projects/page.tsx` to understand the page layout — specifically:
    - The background color (likely `bg-[#fafbfc]` or similar)
    - The max-width and padding classes used in `<main>`
    - The grid layout for project cards

    Match the skeleton layout to the actual page layout so the transition from skeleton to content is smooth.

    **Create `app/projects/error.tsx`:**

    Requirements:
    - MUST have `'use client'` directive (Next.js requires this for error.tsx)
    - Accept `error: Error & { digest?: string }` and `reset: () => void` props (even if unused, for type correctness — use `_error` and `_reset` if not used)
    - Show minimal inline notice, NOT a full-page takeover
    - Casual/light tone — "Couldn't reach GitHub right now." style
    - Slightly visually distinct — use a muted accent color or small dot to signal something is off, without being alarming
    - Match the page's background and spacing so the overall page shell still feels present

    Use the color palette from the existing site. Based on research code example: `text-cat-pink` for the accent dot, `text-slate-400` for the message text. Match whatever the projects page uses for its overall layout (bg color, max-width, padding).

    ```typescript
    // app/projects/error.tsx
    'use client';

    export default function ProjectsError({
      error: _error,
    }: {
      error: Error & { digest?: string };
      reset: () => void;
    }) {
      return (
        <div className="min-h-screen bg-[#fafbfc]">
          <main className="max-w-screen-lg mx-auto px-6 pt-28 md:pt-36 pb-16">
            <p className="text-sm text-slate-400 flex items-center gap-1.5 py-8">
              <span className="text-cat-pink text-base leading-none">·</span>
              Couldn&apos;t reach GitHub right now.
            </p>
          </main>
        </div>
      );
    }
    ```

    Adjust the layout classes to exactly match the projects page's `<main>` wrapper — read the page first.

    **Create `app/projects/loading.tsx`:**

    Requirements:
    - 3 skeleton cards (per user decision)
    - Content-shaped — mirror actual project card dimensions and layout
    - `animate-pulse` (Tailwind built-in opacity fade) — NOT shimmer, NOT custom keyframes
    - Cards should match the actual card layout (rounded corners, border, padding)

    Read the actual project card rendering in projects/page.tsx to match the skeleton proportions accurately.

    ```typescript
    // app/projects/loading.tsx
    export default function ProjectsLoading() {
      return (
        <div className="min-h-screen bg-[#fafbfc]">
          <main className="max-w-screen-lg mx-auto px-6 pt-28 md:pt-36 pb-16">
            <div className="h-8 bg-slate-200 rounded w-32 mb-4 animate-pulse" />
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              {[1, 2, 3].map((i) => (
                <div
                  key={i}
                  className="p-5 rounded-xl border border-slate-200 bg-white animate-pulse"
                >
                  <div className="h-4 bg-slate-200 rounded w-1/2 mb-3" />
                  <div className="h-3 bg-slate-100 rounded w-full mb-2" />
                  <div className="h-3 bg-slate-100 rounded w-3/4 mb-4" />
                  <div className="flex gap-3">
                    <div className="h-3 bg-slate-100 rounded w-16" />
                    <div className="h-3 bg-slate-100 rounded w-10" />
                  </div>
                </div>
              ))}
            </div>
          </main>
        </div>
      );
    }
    ```

    Adjust all layout, spacing, and grid classes to match the actual projects page layout precisely.

  </action>
  <verify>
    - `cat app/projects/error.tsx` starts with `'use client';`
    - `grep "animate-pulse" app/projects/loading.tsx` returns results (pulse animation present)
    - `grep "\[1, 2, 3\]" app/projects/loading.tsx` returns a result (3 skeleton cards)
    - `npx tsc --noEmit` exits 0
    - `npm run build` exits 0 — /projects route builds successfully
    - `/projects` route renders in the Next.js dev server (run `npm run dev` and visit http://localhost:3000/projects)
  </verify>
  <done>app/projects/error.tsx exists as Client Component with casual error message; app/projects/loading.tsx exists with 3 animate-pulse skeleton cards; build passes</done>
</task>

<task type="auto">
  <name>Task 2: Create error.tsx and loading.tsx for /blog route, update root loading.tsx</name>
  <files>
    app/blog/error.tsx
    app/blog/loading.tsx
    app/loading.tsx
  </files>
  <action>
    First, read `app/blog/page.tsx` to understand the blog list layout — specifically:
    - Background color and max-width classes used in `<main>`
    - The layout of individual post items (timeline dot + card? list items? grid?)
    - The spacing and typography classes used

    **Create `app/blog/error.tsx`:**

    Requirements:
    - MUST have `'use client'` directive
    - Accept error/reset props (type them even if unused, prefix unused with `_`)
    - Minimal inline notice matching the blog page aesthetic
    - Casual tone: "Couldn't load posts right now." or similar
    - Match blog page layout (max-width, padding, background)

    Note from Pitfall 2 in research: `getAllPosts()` returning `[]` for empty posts directory is VALID empty state — it won't trigger the error boundary. The blog error.tsx is a safety net for unexpected runtime errors (MDX parse failures, filesystem I/O errors). The wording should reflect this.

    ```typescript
    // app/blog/error.tsx
    'use client';

    export default function BlogError({
      error: _error,
    }: {
      error: Error & { digest?: string };
      reset: () => void;
    }) {
      return (
        <div className="min-h-screen bg-[#fafbfc]">
          <main className="max-w-screen-md mx-auto px-6 pt-28 md:pt-36 pb-16">
            <p className="text-sm text-slate-400 flex items-center gap-1.5 py-8">
              <span className="text-cat-pink text-base leading-none">·</span>
              Couldn&apos;t load posts right now.
            </p>
          </main>
        </div>
      );
    }
    ```

    Adjust layout classes to match the actual blog page layout exactly.

    **Create `app/blog/loading.tsx`:**

    Requirements:
    - Post-shaped rows — each skeleton mirrors: date/meta line, title line, 2-3 excerpt lines (per user decision)
    - Match actual blog list item structure (with timeline dot if present, or just cards)
    - `animate-pulse` opacity fade — no shimmer
    - Render 3 post skeleton rows (matches 3 real posts currently in content/posts/)

    Read the actual blog page post rendering to match the skeleton shape accurately.

    ```typescript
    // app/blog/loading.tsx
    export default function BlogLoading() {
      return (
        <div className="min-h-screen bg-[#fafbfc]">
          <main className="max-w-screen-md mx-auto px-6 pt-28 md:pt-36 pb-16">
            <div className="h-10 bg-slate-200 rounded w-24 mb-12 animate-pulse" />
            <div className="space-y-6">
              {[1, 2, 3].map((i) => (
                <div key={i} className="flex gap-6">
                  <div className="w-4 h-4 rounded-full bg-slate-200 mt-1 flex-shrink-0 animate-pulse" />
                  <div className="flex-1 p-4 rounded-lg border border-slate-200 bg-white animate-pulse">
                    <div className="h-3 bg-slate-100 rounded w-24 mb-3" />
                    <div className="h-5 bg-slate-200 rounded w-3/4 mb-2" />
                    <div className="h-3 bg-slate-100 rounded w-full mb-1.5" />
                    <div className="h-3 bg-slate-100 rounded w-2/3" />
                  </div>
                </div>
              ))}
            </div>
          </main>
        </div>
      );
    }
    ```

    Adjust all layout, spacing, and structure classes to match the actual blog list layout precisely. If the blog page does NOT have a timeline dot layout, adjust accordingly.

    **Update `app/loading.tsx` (root level):**

    Read the current `app/loading.tsx`. If it's just a placeholder ("Loading..."), replace it with a minimal but slightly more polished fallback. This is the global fallback — it shows for routes without their own loading.tsx. Keep it simple since route-specific files now handle the detailed skeletons.

    Suggested minimal update: Replace plain text with a centered container that looks clean, using `animate-pulse` on a simple block. This is at Claude's discretion.

    **Final check:**
    ```
    npx tsc --noEmit
    npm run build
    ```

  </action>
  <verify>
    - `cat app/blog/error.tsx` starts with `'use client';`
    - `grep "animate-pulse" app/blog/loading.tsx` returns results
    - `grep "gap-1.5\|cat-pink\|text-slate-400" app/blog/error.tsx` returns results (error state styling present)
    - `npx tsc --noEmit` exits 0
    - `npm run build` exits 0 — /blog route builds successfully
    - Route structure is correct: run `find app/ -name "error.tsx" -o -name "loading.tsx"` and confirm at minimum: `app/blog/error.tsx`, `app/blog/loading.tsx`, `app/projects/error.tsx`, `app/projects/loading.tsx` all exist
  </verify>
  <done>app/blog/error.tsx and app/blog/loading.tsx exist with correct styling; app/loading.tsx updated; all four route-specific files present; build passes</done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `find app/ -name "error.tsx"` shows: `app/blog/error.tsx`, `app/projects/error.tsx` (at minimum)
2. `find app/ -name "loading.tsx"` shows: `app/blog/loading.tsx`, `app/projects/loading.tsx`, `app/loading.tsx`
3. `grep -l "'use client'" app/blog/error.tsx app/projects/error.tsx` returns both files
4. `grep -rn "animate-pulse" app/blog/loading.tsx app/projects/loading.tsx` returns results in both
5. `npx tsc --noEmit` exits 0
6. `npm run build` exits 0 — all routes build successfully
</verification>

<success_criteria>

- app/projects/error.tsx: Client Component, casual "Couldn't reach GitHub" error notice, muted accent styling
- app/projects/loading.tsx: 3 skeleton cards with animate-pulse, content-shaped to match project card layout
- app/blog/error.tsx: Client Component, casual "Couldn't load posts" error notice
- app/blog/loading.tsx: 3 post-shaped skeleton rows with animate-pulse (meta line + title + excerpt lines)
- app/loading.tsx: Updated root fallback (minimal clean state)
- TypeScript compiles clean
- Build passes — all existing routes still render correctly
  </success_criteria>

<output>
After completion, create `.planning/phases/01-codebase-cleanup/01-04-SUMMARY.md` documenting:
- Layout classes used in each file (matching the source pages read)
- Any adjustments made to the research code examples based on actual page structure
- How the skeleton proportions were matched to real content
- The final root loading.tsx update
- Build output confirming all routes pre-render successfully
</output>
